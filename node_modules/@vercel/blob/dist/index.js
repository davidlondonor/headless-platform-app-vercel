// src/index.ts
import { fetch } from "undici";

// src/helpers.ts
function getToken(options) {
  if (typeof window !== "undefined") {
    if (!(options == null ? void 0 : options.token)) {
      throw new BlobError('"token" is required');
    }
    if (!options.token.startsWith("vercel_blob_client")) {
      throw new BlobError("client upload only supports client tokens");
    }
  }
  if (options == null ? void 0 : options.token) {
    return options.token;
  }
  if (!process.env.BLOB_READ_WRITE_TOKEN) {
    throw new Error(
      "BLOB_READ_WRITE_TOKEN environment variable is not set. Please set it to your write token."
    );
  }
  return process.env.BLOB_READ_WRITE_TOKEN;
}
var BlobError = class extends Error {
  constructor(message) {
    super(`Vercel Blob: ${message}`);
  }
};
var BlobAccessError = class extends Error {
  constructor() {
    super(
      "Vercel Blob: Access denied, please provide a valid token for this resource"
    );
  }
};
var BlobUnknownError = class extends Error {
  constructor() {
    super("Vercel Blob: Unknown error, please contact support@vercel.com");
  }
};

// src/client-upload.ts
import * as crypto from "crypto";
async function generateClientTokenFromReadWriteToken({
  token,
  ...args
}) {
  var _a;
  if (typeof window !== "undefined") {
    throw new Error(
      '"generateClientTokenFromReadWriteToken" must be called from a server environment'
    );
  }
  const timestamp = /* @__PURE__ */ new Date();
  timestamp.setSeconds(timestamp.getSeconds() + 30);
  const blobToken = getToken({ token });
  const [, , , storeId = null] = blobToken.split("_");
  if (!storeId) {
    throw new Error(
      token ? 'Invalid "token" parameter' : "Invalid BLOB_READ_WRITE_TOKEN"
    );
  }
  const payload = Buffer.from(
    JSON.stringify({
      ...args,
      validUntil: (_a = args.validUntil) != null ? _a : timestamp.getTime()
    })
  ).toString("base64");
  const securedKey = await signPayload(payload, blobToken);
  if (!securedKey) {
    throw new Error("Unable to sign client token");
  }
  return `vercel_blob_client_${storeId}_${Buffer.from(
    `${securedKey}.${payload}`
  ).toString("base64")}`;
}
async function importKey(token) {
  return globalThis.crypto.subtle.importKey(
    "raw",
    new TextEncoder().encode(getToken({ token })),
    { name: "HMAC", hash: "SHA-256" },
    false,
    ["sign", "verify"]
  );
}
async function signPayload(payload, token) {
  if (!globalThis.crypto) {
    return crypto.createHmac("sha256", token).update(payload).digest("hex");
  }
  const signature = await globalThis.crypto.subtle.sign(
    "HMAC",
    await importKey(token),
    new TextEncoder().encode(payload)
  );
  return Buffer.from(new Uint8Array(signature)).toString("hex");
}
async function verifyCallbackSignature({
  token,
  signature,
  body
}) {
  const secret = getToken({ token });
  if (!globalThis.crypto) {
    const digest = crypto.createHmac("sha256", secret).update(body).digest("hex");
    const digestBuffer = Buffer.from(digest);
    const signatureBuffer = Buffer.from(signature);
    return digestBuffer.length === signatureBuffer.length && crypto.timingSafeEqual(digestBuffer, signatureBuffer);
  }
  const verified = await globalThis.crypto.subtle.verify(
    "HMAC",
    await importKey(token),
    hexToArrayByte(signature),
    new TextEncoder().encode(body)
  );
  return verified;
}
function hexToArrayByte(input) {
  if (input.length % 2 !== 0) {
    throw new RangeError("Expected string to be an even number of characters");
  }
  const view = new Uint8Array(input.length / 2);
  for (let i = 0; i < input.length; i += 2) {
    view[i / 2] = parseInt(input.substring(i, i + 2), 16);
  }
  return Buffer.from(view);
}
function getPayloadFromClientToken(clientToken) {
  const [, , , , encodedToken] = clientToken.split("_");
  const encodedPayload = Buffer.from(encodedToken != null ? encodedToken : "", "base64").toString().split(".")[1];
  const decodedPayload = Buffer.from(encodedPayload != null ? encodedPayload : "", "base64").toString();
  return JSON.parse(decodedPayload);
}
var EventTypes = {
  generateClientToken: "blob.generate-client-token",
  uploadCompleted: "blob.upload-completed"
};
async function handleBlobUpload({
  token,
  request,
  body,
  onBeforeGenerateToken,
  onUploadCompleted
}) {
  var _a, _b, _c;
  if (!body.type)
    throw new Error("Invalid event type");
  const type = body.type;
  switch (type) {
    case "blob.generate-client-token": {
      const { pathname, callbackUrl } = body.payload;
      const payload = await onBeforeGenerateToken(pathname);
      return {
        type,
        clientToken: await generateClientTokenFromReadWriteToken({
          ...payload,
          token,
          pathname,
          onUploadCompleted: {
            callbackUrl,
            metadata: (_a = payload.metadata) != null ? _a : null
          }
        })
      };
    }
    case "blob.upload-completed": {
      const signatureHeader = "x-vercel-signature";
      const signature = "credentials" in request ? (_b = request.headers.get(signatureHeader)) != null ? _b : "" : (_c = request.headers[signatureHeader]) != null ? _c : "";
      if (!signature) {
        throw new Error("Invalid callback signature");
      }
      const isVerified = await verifyCallbackSignature({
        signature,
        body: JSON.stringify(body)
      });
      if (!isVerified) {
        throw new Error("Invalid callback signature");
      }
      await onUploadCompleted(body.payload);
      return { type, response: "ok" };
    }
    default:
      throw new Error("Invalid event type");
  }
}

// src/index.ts
var BLOB_API_VERSION = 1;
async function put(pathname, body, options) {
  if (!pathname) {
    throw new BlobError("pathname is required");
  }
  if (!body) {
    throw new BlobError("body is required");
  }
  if (!options || options.access !== "public") {
    throw new BlobError('access must be "public"');
  }
  const token = shouldFetchClientToken(options) ? await retrieveClientToken({
    handleBlobUploadUrl: options.handleBlobUploadUrl,
    pathname
  }) : getToken(options);
  const headers = {
    ...getApiVersionHeader(),
    authorization: `Bearer ${token}`
  };
  if (options.contentType) {
    headers["x-content-type"] = options.contentType;
  }
  const blobApiResponse = await fetch(getApiUrl(`/${pathname}`), {
    method: "PUT",
    body,
    headers,
    // required in order to stream some body types to Cloudflare
    // currently only supported in Node.js, we may have to feature detect this
    duplex: "half"
  });
  if (blobApiResponse.status !== 200) {
    if (blobApiResponse.status === 403) {
      throw new BlobAccessError();
    } else {
      throw new BlobUnknownError();
    }
  }
  const blobResult = await blobApiResponse.json();
  return mapBlobResult(blobResult);
}
async function del(url, options) {
  const blobApiResponse = await fetch(getApiUrl("/delete"), {
    method: "POST",
    headers: {
      ...getApiVersionHeader(),
      authorization: `Bearer ${getToken(options)}`,
      "content-type": "application/json"
    },
    body: JSON.stringify({ urls: Array.isArray(url) ? url : [url] })
  });
  if (blobApiResponse.status !== 200) {
    if (blobApiResponse.status === 403) {
      throw new BlobAccessError();
    } else {
      throw new BlobUnknownError();
    }
  }
  const delResult = await blobApiResponse.json();
  if (Array.isArray(url)) {
    return delResult.map(
      (deletedBlob) => deletedBlob ? mapBlobResult(deletedBlob) : null
    );
  }
  if (delResult[0]) {
    return mapBlobResult(delResult[0]);
  }
  return null;
}
async function head(url, options) {
  const headApiUrl = new URL(getApiUrl());
  headApiUrl.searchParams.set("url", url);
  const blobApiResponse = await fetch(headApiUrl, {
    method: "GET",
    // HEAD can't have body as a response, so we use GET
    headers: {
      ...getApiVersionHeader(),
      authorization: `Bearer ${getToken(options)}`
    }
  });
  if (blobApiResponse.status === 404) {
    return null;
  }
  if (blobApiResponse.status !== 200) {
    if (blobApiResponse.status === 403) {
      throw new BlobAccessError();
    } else {
      throw new BlobUnknownError();
    }
  }
  const headResult = await blobApiResponse.json();
  return mapBlobResult(headResult);
}
async function list(options) {
  const listApiUrl = new URL(getApiUrl());
  if (options == null ? void 0 : options.limit) {
    listApiUrl.searchParams.set("limit", options.limit.toString());
  }
  if (options == null ? void 0 : options.prefix) {
    listApiUrl.searchParams.set("prefix", options.prefix);
  }
  if (options == null ? void 0 : options.cursor) {
    listApiUrl.searchParams.set("cursor", options.cursor);
  }
  const blobApiResponse = await fetch(listApiUrl, {
    method: "GET",
    headers: {
      ...getApiVersionHeader(),
      authorization: `Bearer ${getToken(options)}`
    }
  });
  if (blobApiResponse.status !== 200) {
    if (blobApiResponse.status === 403) {
      throw new BlobAccessError();
    } else {
      throw new BlobUnknownError();
    }
  }
  const results = await blobApiResponse.json();
  return {
    ...results,
    blobs: results.blobs.map(mapBlobResult)
  };
}
function getApiUrl(pathname = "") {
  const baseUrl = process.env.VERCEL_BLOB_API_URL || process.env.NEXT_PUBLIC_VERCEL_BLOB_API_URL || "https://blob.vercel-storage.com";
  return `${baseUrl}${pathname}`;
}
function mapBlobResult(blobResult) {
  if (blobResult.uploadedAt) {
    return {
      ...blobResult,
      uploadedAt: new Date(blobResult.uploadedAt)
    };
  }
  return blobResult;
}
function isAbsoluteUrl(url) {
  try {
    return Boolean(new URL(url));
  } catch (e) {
    return false;
  }
}
async function retrieveClientToken(options) {
  const { handleBlobUploadUrl, pathname } = options;
  const url = isAbsoluteUrl(handleBlobUploadUrl) ? handleBlobUploadUrl : `${window.location.origin}${handleBlobUploadUrl}`;
  const res = await fetch(url, {
    method: "POST",
    body: JSON.stringify({
      type: EventTypes.generateClientToken,
      payload: { pathname, callbackUrl: url }
    })
  });
  if (!res.ok) {
    throw new BlobError("Failed to  retrieve the client token");
  }
  try {
    const { clientToken } = await res.json();
    return clientToken;
  } catch (e) {
    throw new BlobError("Failed to retrieve the client token");
  }
}
function shouldFetchClientToken(options) {
  return Boolean(!options.token && options.handleBlobUploadUrl);
}
function getApiVersionHeader() {
  if (process.env.VERCEL_BLOB_USE_API_VERSION === "true") {
    return {
      "x-api-version": `${BLOB_API_VERSION}`
    };
  }
  return {};
}
export {
  BlobAccessError,
  BlobError,
  BlobUnknownError,
  del,
  generateClientTokenFromReadWriteToken,
  getPayloadFromClientToken,
  handleBlobUpload,
  head,
  list,
  put,
  verifyCallbackSignature
};
//# sourceMappingURL=index.js.map