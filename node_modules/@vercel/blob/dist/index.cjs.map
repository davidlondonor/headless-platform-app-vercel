{"version":3,"sources":["../src/index.ts","../src/helpers.ts","../src/client-upload.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Readable } from 'node:stream';\nimport type { BodyInit } from 'undici';\n// When bundled via a bundler supporting the `browser` field, then\n// the `undici` module will be replaced with https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API\n// for browser contexts. See ./undici-browser.js and ./package.json\nimport { fetch } from 'undici';\nimport {\n  BlobAccessError,\n  BlobError,\n  BlobUnknownError,\n  getToken,\n} from './helpers';\nimport { EventTypes, type GenerateClientTokenEvent } from './client-upload';\n\nexport { BlobAccessError, BlobError, BlobUnknownError };\nexport {\n  generateClientTokenFromReadWriteToken,\n  getPayloadFromClientToken,\n  verifyCallbackSignature,\n  handleBlobUpload,\n  type BlobUploadCompletedEvent,\n  type GenerateClientTokenOptions,\n  type HandleBlobUploadBody,\n  type HandleBlobUploadOptions,\n} from './client-upload';\n\nexport interface BlobResult {\n  url: string;\n  size: string;\n  uploadedAt: Date;\n  pathname: string;\n  contentType: string;\n  contentDisposition: string;\n}\n\nexport interface ListBlobResult {\n  blobs: BlobResult[];\n  cursor?: string;\n  hasMore: boolean;\n}\n\nexport interface ListCommandOptions extends BlobCommandOptions {\n  limit?: number;\n  prefix?: string;\n  cursor?: string;\n}\n\nexport interface BlobCommandOptions {\n  token?: string;\n}\n\nexport interface PutCommandOptions extends BlobCommandOptions {\n  access: 'public';\n  contentType?: string;\n  handleBlobUploadUrl?: string;\n}\n\nconst BLOB_API_VERSION = 1;\n\nexport async function put(\n  pathname: string,\n  body:\n    | string\n    | Readable\n    | Blob\n    | ArrayBuffer\n    | FormData\n    | ReadableStream\n    | File,\n  options: PutCommandOptions,\n): Promise<BlobResult> {\n  if (!pathname) {\n    throw new BlobError('pathname is required');\n  }\n\n  if (!body) {\n    throw new BlobError('body is required');\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  if (!options || options.access !== 'public') {\n    throw new BlobError('access must be \"public\"');\n  }\n\n  const token = shouldFetchClientToken(options)\n    ? await retrieveClientToken({\n        handleBlobUploadUrl: options.handleBlobUploadUrl,\n        pathname,\n      })\n    : getToken(options);\n\n  const headers: Record<string, string> = {\n    ...getApiVersionHeader(),\n    authorization: `Bearer ${token}`,\n  };\n\n  if (options.contentType) {\n    headers['x-content-type'] = options.contentType;\n  }\n\n  const blobApiResponse = await fetch(getApiUrl(`/${pathname}`), {\n    method: 'PUT',\n    body: body as BodyInit,\n    headers,\n    // required in order to stream some body types to Cloudflare\n    // currently only supported in Node.js, we may have to feature detect this\n    duplex: 'half',\n  });\n\n  if (blobApiResponse.status !== 200) {\n    if (blobApiResponse.status === 403) {\n      throw new BlobAccessError();\n    } else {\n      throw new BlobUnknownError();\n    }\n  }\n\n  const blobResult = (await blobApiResponse.json()) as BlobMetadataApi;\n  return mapBlobResult(blobResult);\n}\n\ntype BlobDelResult<T extends string | string[]> = T extends string\n  ? BlobResult | null\n  : (BlobResult | null)[];\n\nexport async function del<T extends string | string[]>(\n  url: T,\n  options?: BlobCommandOptions,\n): Promise<BlobDelResult<T>> {\n  const blobApiResponse = await fetch(getApiUrl('/delete'), {\n    method: 'POST',\n    headers: {\n      ...getApiVersionHeader(),\n      authorization: `Bearer ${getToken(options)}`,\n      'content-type': 'application/json',\n    },\n    body: JSON.stringify({ urls: Array.isArray(url) ? url : [url] }),\n  });\n\n  if (blobApiResponse.status !== 200) {\n    if (blobApiResponse.status === 403) {\n      throw new BlobAccessError();\n    } else {\n      throw new BlobUnknownError();\n    }\n  }\n\n  const delResult =\n    (await blobApiResponse.json()) as (BlobMetadataApi | null)[];\n\n  if (Array.isArray(url)) {\n    return delResult.map((deletedBlob) =>\n      deletedBlob ? mapBlobResult(deletedBlob) : null,\n    ) as BlobDelResult<T>;\n  }\n  if (delResult[0]) {\n    return mapBlobResult(delResult[0]) as BlobDelResult<T>;\n  }\n  return null as BlobDelResult<T>;\n}\n\ninterface BlobMetadataApi extends Omit<BlobResult, 'uploadedAt'> {\n  uploadedAt: string;\n}\ninterface ListBlobResultApi extends Omit<ListBlobResult, 'blobs'> {\n  blobs: BlobMetadataApi[];\n}\n\nexport async function head(\n  url: string,\n  options?: BlobCommandOptions,\n): Promise<BlobResult | null> {\n  const headApiUrl = new URL(getApiUrl());\n  headApiUrl.searchParams.set('url', url);\n\n  const blobApiResponse = await fetch(headApiUrl, {\n    method: 'GET', // HEAD can't have body as a response, so we use GET\n    headers: {\n      ...getApiVersionHeader(),\n      authorization: `Bearer ${getToken(options)}`,\n    },\n  });\n\n  if (blobApiResponse.status === 404) {\n    return null;\n  }\n\n  if (blobApiResponse.status !== 200) {\n    if (blobApiResponse.status === 403) {\n      throw new BlobAccessError();\n    } else {\n      throw new BlobUnknownError();\n    }\n  }\n\n  const headResult = (await blobApiResponse.json()) as BlobMetadataApi;\n\n  return mapBlobResult(headResult);\n}\n\nexport async function list(\n  options?: ListCommandOptions,\n): Promise<ListBlobResult> {\n  const listApiUrl = new URL(getApiUrl());\n  if (options?.limit) {\n    listApiUrl.searchParams.set('limit', options.limit.toString());\n  }\n  if (options?.prefix) {\n    listApiUrl.searchParams.set('prefix', options.prefix);\n  }\n  if (options?.cursor) {\n    listApiUrl.searchParams.set('cursor', options.cursor);\n  }\n  const blobApiResponse = await fetch(listApiUrl, {\n    method: 'GET',\n    headers: {\n      ...getApiVersionHeader(),\n      authorization: `Bearer ${getToken(options)}`,\n    },\n  });\n\n  if (blobApiResponse.status !== 200) {\n    if (blobApiResponse.status === 403) {\n      throw new BlobAccessError();\n    } else {\n      throw new BlobUnknownError();\n    }\n  }\n\n  const results = (await blobApiResponse.json()) as ListBlobResultApi;\n\n  return {\n    ...results,\n    blobs: results.blobs.map(mapBlobResult),\n  };\n}\n\nfunction getApiUrl(pathname = ''): string {\n  const baseUrl =\n    process.env.VERCEL_BLOB_API_URL ||\n    process.env.NEXT_PUBLIC_VERCEL_BLOB_API_URL ||\n    'https://blob.vercel-storage.com';\n\n  return `${baseUrl}${pathname}`;\n}\n\nfunction mapBlobResult(blobResult: BlobMetadataApi): BlobResult {\n  // TODO: temporary fix for misaligned types given multibucket migration\n  if (blobResult.uploadedAt) {\n    return {\n      ...blobResult,\n      uploadedAt: new Date(blobResult.uploadedAt),\n    };\n  }\n\n  return blobResult as unknown as BlobResult;\n}\n\nfunction isAbsoluteUrl(url: string): boolean {\n  try {\n    return Boolean(new URL(url));\n  } catch (e) {\n    return false;\n  }\n}\n\nasync function retrieveClientToken(options: {\n  pathname: string;\n  handleBlobUploadUrl: string;\n}): Promise<string> {\n  const { handleBlobUploadUrl, pathname } = options;\n  const url = isAbsoluteUrl(handleBlobUploadUrl)\n    ? handleBlobUploadUrl\n    : `${window.location.origin}${handleBlobUploadUrl}`;\n\n  const res = await fetch(url, {\n    method: 'POST',\n    body: JSON.stringify({\n      type: EventTypes.generateClientToken,\n      payload: { pathname, callbackUrl: url },\n    } as GenerateClientTokenEvent),\n  });\n  if (!res.ok) {\n    throw new BlobError('Failed to  retrieve the client token');\n  }\n  try {\n    const { clientToken } = (await res.json()) as { clientToken: string };\n    return clientToken;\n  } catch (e) {\n    throw new BlobError('Failed to retrieve the client token');\n  }\n}\n\ninterface ReturnPutCommandOptions {\n  handleBlobUploadUrl: string;\n  access: 'public';\n  token: undefined;\n}\n\nfunction shouldFetchClientToken(\n  options: PutCommandOptions,\n): options is ReturnPutCommandOptions {\n  return Boolean(!options.token && options.handleBlobUploadUrl);\n}\n\nfunction getApiVersionHeader(): { 'x-api-version'?: string } {\n  if (process.env.VERCEL_BLOB_USE_API_VERSION === 'true') {\n    return {\n      'x-api-version': `${BLOB_API_VERSION}`,\n    };\n  }\n\n  return {};\n}\n","import { type BlobCommandOptions } from '.';\n\nexport function getToken(options?: BlobCommandOptions): string {\n  if (typeof window !== 'undefined') {\n    if (!options?.token) {\n      throw new BlobError('\"token\" is required');\n    }\n    if (!options.token.startsWith('vercel_blob_client')) {\n      throw new BlobError('client upload only supports client tokens');\n    }\n  }\n  if (options?.token) {\n    return options.token;\n  }\n\n  if (!process.env.BLOB_READ_WRITE_TOKEN) {\n    throw new Error(\n      'BLOB_READ_WRITE_TOKEN environment variable is not set. Please set it to your write token.',\n    );\n  }\n\n  return process.env.BLOB_READ_WRITE_TOKEN;\n}\n\nexport class BlobError extends Error {\n  constructor(message: string) {\n    super(`Vercel Blob: ${message}`);\n  }\n}\n\nexport class BlobAccessError extends Error {\n  constructor() {\n    super(\n      'Vercel Blob: Access denied, please provide a valid token for this resource',\n    );\n  }\n}\n\nexport class BlobUnknownError extends Error {\n  constructor() {\n    super('Vercel Blob: Unknown error, please contact support@vercel.com');\n  }\n}\n","// eslint-disable-next-line unicorn/prefer-node-protocol -- node:crypto does not resolve correctly in browser and edge runtime\nimport * as crypto from 'crypto';\nimport type { IncomingMessage } from 'node:http';\nimport { getToken } from './helpers';\nimport { type BlobResult, type BlobCommandOptions } from '.';\n\nexport interface GenerateClientTokenOptions extends BlobCommandOptions {\n  pathname: string;\n  onUploadCompleted?: {\n    callbackUrl: string;\n    metadata?: string | null;\n  };\n  maximumSizeInBytes?: number;\n  allowedContentTypes?: string[];\n  validUntil?: number;\n}\n\nexport async function generateClientTokenFromReadWriteToken({\n  token,\n  ...args\n}: GenerateClientTokenOptions): Promise<string> {\n  if (typeof window !== 'undefined') {\n    throw new Error(\n      '\"generateClientTokenFromReadWriteToken\" must be called from a server environment',\n    );\n  }\n  const timestamp = new Date();\n  timestamp.setSeconds(timestamp.getSeconds() + 30);\n  const blobToken = getToken({ token });\n\n  const [, , , storeId = null] = blobToken.split('_');\n\n  if (!storeId) {\n    throw new Error(\n      token ? 'Invalid \"token\" parameter' : 'Invalid BLOB_READ_WRITE_TOKEN',\n    );\n  }\n\n  const payload = Buffer.from(\n    JSON.stringify({\n      ...args,\n      validUntil: args.validUntil ?? timestamp.getTime(),\n    }),\n  ).toString('base64');\n\n  const securedKey = await signPayload(payload, blobToken);\n  if (!securedKey) {\n    throw new Error('Unable to sign client token');\n  }\n  return `vercel_blob_client_${storeId}_${Buffer.from(\n    `${securedKey}.${payload}`,\n  ).toString('base64')}`;\n}\n\nasync function importKey(token?: string): Promise<CryptoKey> {\n  return globalThis.crypto.subtle.importKey(\n    'raw',\n    new TextEncoder().encode(getToken({ token })),\n    { name: 'HMAC', hash: 'SHA-256' },\n    false,\n    ['sign', 'verify'],\n  );\n}\n\nasync function signPayload(\n  payload: string,\n  token: string,\n): Promise<string | undefined> {\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  if (!globalThis.crypto) {\n    return crypto.createHmac('sha256', token).update(payload).digest('hex');\n  }\n\n  const signature = await globalThis.crypto.subtle.sign(\n    'HMAC',\n    await importKey(token),\n    new TextEncoder().encode(payload),\n  );\n  return Buffer.from(new Uint8Array(signature)).toString('hex');\n}\n\nexport async function verifyCallbackSignature({\n  token,\n  signature,\n  body,\n}: {\n  token?: string;\n  signature: string;\n  body: string;\n}): Promise<boolean> {\n  // callback signature is signed using the server token\n  const secret = getToken({ token });\n  // Browsers, Edge runtime and Node >=20 implement the Web Crypto API\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  if (!globalThis.crypto) {\n    // Node <20 falls back to the Node.js crypto module\n    const digest = crypto\n      .createHmac('sha256', secret)\n      .update(body)\n      .digest('hex');\n    const digestBuffer = Buffer.from(digest);\n    const signatureBuffer = Buffer.from(signature);\n\n    return (\n      digestBuffer.length === signatureBuffer.length &&\n      crypto.timingSafeEqual(digestBuffer, signatureBuffer)\n    );\n  }\n  const verified = await globalThis.crypto.subtle.verify(\n    'HMAC',\n    await importKey(token),\n    hexToArrayByte(signature),\n    new TextEncoder().encode(body),\n  );\n  return verified;\n}\n\nfunction hexToArrayByte(input: string): ArrayBuffer {\n  if (input.length % 2 !== 0) {\n    throw new RangeError('Expected string to be an even number of characters');\n  }\n  const view = new Uint8Array(input.length / 2);\n\n  for (let i = 0; i < input.length; i += 2) {\n    view[i / 2] = parseInt(input.substring(i, i + 2), 16);\n  }\n\n  return Buffer.from(view);\n}\n\ntype DecodedClientTokenPayload = Omit<GenerateClientTokenOptions, 'token'> & {\n  validUntil: number;\n};\n\nexport function getPayloadFromClientToken(\n  clientToken: string,\n): DecodedClientTokenPayload {\n  const [, , , , encodedToken] = clientToken.split('_');\n  const encodedPayload = Buffer.from(encodedToken ?? '', 'base64')\n    .toString()\n    .split('.')[1];\n  const decodedPayload = Buffer.from(encodedPayload ?? '', 'base64').toString();\n  return JSON.parse(decodedPayload) as DecodedClientTokenPayload;\n}\n\nexport const EventTypes = {\n  generateClientToken: 'blob.generate-client-token',\n  uploadCompleted: 'blob.upload-completed',\n} as const;\n\nexport interface GenerateClientTokenEvent {\n  type: (typeof EventTypes)['generateClientToken'];\n  payload: { pathname: string; callbackUrl: string };\n}\nexport interface BlobUploadCompletedEvent {\n  type: (typeof EventTypes)['uploadCompleted'];\n  payload: {\n    blob: BlobResult;\n    metadata?: string;\n  };\n}\n\nexport type HandleBlobUploadBody =\n  | GenerateClientTokenEvent\n  | BlobUploadCompletedEvent;\n\ntype RequestType = IncomingMessage | Request;\nexport interface HandleBlobUploadOptions {\n  body: HandleBlobUploadBody;\n  onBeforeGenerateToken: (\n    pathname: string,\n  ) => Promise<\n    Pick<\n      GenerateClientTokenOptions,\n      'allowedContentTypes' | 'maximumSizeInBytes' | 'validUntil'\n    > & { metadata?: string }\n  >;\n  onUploadCompleted: (\n    body: BlobUploadCompletedEvent['payload'],\n  ) => Promise<void>;\n  token?: string;\n  request: RequestType;\n}\n\nexport async function handleBlobUpload({\n  token,\n  request,\n  body,\n  onBeforeGenerateToken,\n  onUploadCompleted,\n}: HandleBlobUploadOptions): Promise<\n  | { type: GenerateClientTokenEvent['type']; clientToken: string }\n  | { type: BlobUploadCompletedEvent['type']; response: 'ok' }\n> {\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  if (!body.type) throw new Error('Invalid event type');\n  const type = body.type;\n  switch (type) {\n    case 'blob.generate-client-token': {\n      const { pathname, callbackUrl } = body.payload;\n      const payload = await onBeforeGenerateToken(pathname);\n      return {\n        type,\n        clientToken: await generateClientTokenFromReadWriteToken({\n          ...payload,\n          token,\n          pathname,\n          onUploadCompleted: {\n            callbackUrl,\n            metadata: payload.metadata ?? null,\n          },\n        }),\n      };\n    }\n    case 'blob.upload-completed': {\n      const signatureHeader = 'x-vercel-signature';\n      const signature = (\n        'credentials' in request\n          ? request.headers.get(signatureHeader) ?? ''\n          : request.headers[signatureHeader] ?? ''\n      ) as string;\n      if (!signature) {\n        throw new Error('Invalid callback signature');\n      }\n      const isVerified = await verifyCallbackSignature({\n        signature,\n        body: JSON.stringify(body),\n      });\n      if (!isVerified) {\n        throw new Error('Invalid callback signature');\n      }\n      await onUploadCompleted(body.payload);\n      return { type, response: 'ok' };\n    }\n    default:\n      throw new Error('Invalid event type');\n  }\n}\n"]}