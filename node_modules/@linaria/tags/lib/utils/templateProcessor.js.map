{"version":3,"file":"templateProcessor.js","names":["unitRegex","RegExp","units","join","templateProcessor","tagProcessor","template","valueCache","variableNameConfig","sourceMapReplacements","isReferenced","cssText","item","lastTemplateElementLocation","shift","value","cooked","loc","ex","end","beforeLength","length","next","start","line","column","get","name","kind","ValueType","FUNCTION","matches","match","unit","varId","addInterpolation","source","getVariableName","substring","e","Error","buildCodeFrameError","message","throwIfInvalid","isValidValue","bind","undefined","hasMeta","__linaria","className","isCSSable","stripLines","toCSS","push","original","rules","extractRules","location","includes"],"sources":["../../src/utils/templateProcessor.ts"],"sourcesContent":["/* eslint-disable no-continue */\n/**\n * This file handles transforming template literals to class names or styled components and generates CSS content.\n * It uses CSS code from template literals and evaluated values of lazy dependencies stored in ValueCache.\n */\n\nimport type { TemplateElement, SourceLocation } from '@babel/types';\n\nimport type TaggedTemplateProcessor from '../TaggedTemplateProcessor';\nimport type {\n  ExpressionValue,\n  ValueCache,\n  Rules,\n  Replacements,\n} from '../types';\nimport { ValueType } from '../types';\n\nimport { getVariableName } from './getVariableName';\nimport hasMeta from './hasMeta';\nimport stripLines from './stripLines';\nimport throwIfInvalid from './throwIfInvalid';\nimport toCSS, { isCSSable } from './toCSS';\nimport type { IOptions } from './types';\nimport { units } from './units';\n\n// Match any valid CSS units followed by a separator such as ;, newline etc.\nconst unitRegex = new RegExp(`^(?:${units.join('|')})\\\\b`);\n\nexport default function templateProcessor(\n  tagProcessor: TaggedTemplateProcessor,\n  [...template]: (TemplateElement | ExpressionValue)[],\n  valueCache: ValueCache,\n  variableNameConfig: IOptions['variableNameConfig'] | undefined\n): [rules: Rules, sourceMapReplacements: Replacements] | null {\n  const sourceMapReplacements: Replacements = [];\n  // Check if the variable is referenced anywhere for basic DCE\n  // Only works when it's assigned to a variable\n  const { isReferenced } = tagProcessor;\n\n  // Serialize the tagged template literal to a string\n  let cssText = '';\n\n  let item: TemplateElement | ExpressionValue | undefined;\n  let lastTemplateElementLocation: SourceLocation | null | undefined;\n  // eslint-disable-next-line no-cond-assign\n  while ((item = template.shift())) {\n    if ('type' in item) {\n      // It's a template element\n      cssText += item.value.cooked;\n      lastTemplateElementLocation = item.loc;\n      continue;\n    }\n\n    // It's an expression\n    const { ex } = item;\n\n    const { end } = ex.loc!;\n    const beforeLength = cssText.length;\n\n    // The location will be end of the current string to start of next string\n    const next = template[0] as TemplateElement; // template[0] is the next template element\n    const loc = {\n      // +1 because an expression location always shows 1 column before\n      start: {\n        line: lastTemplateElementLocation!.end.line,\n        column: lastTemplateElementLocation!.end.column + 1,\n      },\n      end: next\n        ? { line: next.loc!.start.line, column: next.loc!.start.column }\n        : { line: end.line, column: end.column + 1 },\n    };\n\n    const value = 'value' in item ? item.value : valueCache.get(item.ex.name);\n\n    // Is it props based interpolation?\n    if (item.kind === ValueType.FUNCTION || typeof value === 'function') {\n      // Check if previous expression was a CSS variable that we replaced\n      // If it has a unit after it, we need to move the unit into the interpolation\n      // e.g. `var(--size)px` should actually be `var(--size)`\n      // So we check if the current text starts with a unit, and add the unit to the previous interpolation\n      // Another approach would be `calc(var(--size) * 1px), but some browsers don't support all units\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=956573\n      const matches = next.value.cooked?.match(unitRegex);\n\n      try {\n        if (matches) {\n          template.shift();\n          const [unit] = matches;\n\n          const varId = tagProcessor.addInterpolation(\n            item.ex,\n            cssText,\n            item.source,\n            unit\n          );\n          cssText += getVariableName(varId, variableNameConfig);\n\n          cssText += next.value.cooked?.substring(unit?.length ?? 0) ?? '';\n        } else {\n          const varId = tagProcessor.addInterpolation(\n            item.ex,\n            cssText,\n            item.source\n          );\n          cssText += getVariableName(varId, variableNameConfig);\n        }\n      } catch (e) {\n        if (e instanceof Error) {\n          throw item.buildCodeFrameError(e.message);\n        }\n\n        throw e;\n      }\n    } else {\n      throwIfInvalid(\n        tagProcessor.isValidValue.bind(tagProcessor),\n        value,\n        item,\n        item.source\n      );\n\n      if (value !== undefined && typeof value !== 'function') {\n        // Skip the blank string instead of throw ing an error\n        if (value === '') {\n          continue;\n        }\n\n        if (hasMeta(value)) {\n          // If it's a React component wrapped in styled, get the class name\n          // Useful for interpolating components\n          cssText += `.${value.__linaria.className}`;\n        } else if (isCSSable(value)) {\n          // If it's a plain object or an array, convert it to a CSS string\n          cssText += stripLines(loc, toCSS(value));\n        } else {\n          // For anything else, assume it'll be stringified\n          cssText += stripLines(loc, value);\n        }\n\n        sourceMapReplacements.push({\n          original: loc,\n          length: cssText.length - beforeLength,\n        });\n      }\n    }\n  }\n\n  const rules = tagProcessor.extractRules(\n    valueCache,\n    cssText,\n    tagProcessor.location\n  );\n\n  // tagProcessor.doRuntimeReplacement(classes);\n  if (!isReferenced && !cssText.includes(':global')) {\n    return null;\n  }\n\n  // eslint-disable-next-line no-param-reassign\n  return [rules, sourceMapReplacements];\n}\n"],"mappings":"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"}